<!doctype html>
<html lang="en">

	<head>
		<meta charset="gbk">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>《Java编程思想》 读书分享</h2>
					<h3>烽火读书会</h3>
					<p>2013-9-4</p>
				</section>

				<section>
					<h3>目录</h3>
					<ul>
						<li class="fragment highlight-blue"><strong>Java面向对象程序设计的基本特征</strong></li>
						<li>接口</li>
						<li>内部类</li>
						<li>泛型</li>
						<li>字符串</li>
					</ul>
				</section>

				<!-- Example of nested vertical slides -->
				<section>
					<section>
					<h3>Java面向对象程序设计的基本特征</h3>
					<ul>
						<li class="fragment">封装</li> 
						<li class="fragment">继承</li>
						<li class="fragment">多态</li>
					</ul>
				    </section>
					<section>
					<h3>封装</h3>
					<p align=left>1. 什么是封装？</p>
					<p align=left>封装就是将属性私有化，提供公有的方法访问私有属性。如：</p> 
					<pre><code data-trim contenteditable>
					private String name;
  public String getName(){
    retun name;
  }
  public void setName(){
    this.name = name;
  } 
					</code></pre>
				    </section>
				    <section>
				    <h3>继承</h3>
                    <p align=left>1. 生活中，继承的例子随处可见，如：</p>
                    <img src="tupian/tupian1.gif">
                    <p align=left>2. 使用继承的好处？</p>
                    <p align=left>使用继承提高代码的复用性</p>
				    </section>
				    <section>
				    <h3>继承</h3>
                    <p align=left>3. 如何实现继承</p>
                    <p align=left>在Java语言中，用extends关键字表示一个类继承另一个类，例如：</p>
                    <pre><code data-trim contenteditable>
                      public class Son extends Father{
    //其余代码省略
  }
                    </code></pre>
                    <p align=left>在父类中只定义一些通用的属性与方法，例如：</p>
                    <pre><code data-trim contenteditable>
                    public class Animal{
    private String name;
    pulic Animal(String name){
      //初始化属性值
    }
    public void eat(){
      //吃方法的具体实现
    }
  }
                    </code></pre>
                    </section>
                    <section>
                    <p align=left>子类自动继承父类的属性和方法，子类中可以定义特定的属性和方法，如：</p>
                    <pre><code data-trim contenteditable>
                    public class Lion extends Animal{
    public Lion(String name){
      super(name);
    }
    public void eat(){
      System.out.println(“继承父类eat()”);
      super.eat();
    }
  }
                    </code></pre>
				    </section>
				    <section>
				    <h3>多态</h3>
                    <p align=left>1. 什么是多态？</p>
                    <p align=left>指父类中定义的属性与方法被子类继承后，可以具有不同的数据类型或行为。</p>
                    <p align=left>2. 生活中的多态，如：</p>
                    <img src="tupian/tupian2.gif">
				    </section>
				    <section>
				    <h3>多态</h3>
                    <p align=left>3. 多态是通过覆盖父类的方法来实现，在运行是根据传递的对象引用，来实现相应的方法，如：</p>
                    <pre><code data-trim contenteditable>
                    public static void main(String[] args){
    A a = new B();
    a.print();
  }
  static class A{
    void print(){
      System.out.println(“This is A.”);
    }
  }
static class B{
    void print(){
      System.out.println(“This is B.”);
    }
  }
                    </code></pre>
                    </section>
				</section> 
				
                <section>
                <h3>目录</h3>
					<ul>
						<li>Java面向对象程序设计的基本特征</li>
						<li class="fragment highlight-blue"><strong>接口</strong></li>
						<li>内部类</li>
						<li>泛型</li>
						<li>字符串</li>
					</ul>
                </section>
                
                <section>
                <section>
                <h3>接口</h3>
                  <p align=left>1. Java中的多重继承</p>
                  <p align=left>接口是实现多重继承的途径</p>
                  <p align=left>多重继承：子类可以实现多个接口;子类只能继承一个父类</p>
                  <pre><code data-trim contenteditable>
                     class A{}
   class B{}
   class C extends A{}
   interface D{}
   interface E{}
   interface F extends D,E{}
   public class Test extends C implements D,E
                  </code></pre>
                  <p align=left>使用接口的核心原因：</p>
                  <p align=left>a. 为了能够向上转型为多个基类型（以及由此带来的灵活性）</p>
                  <p align=left>b. 与使用抽象类相同:防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口</p>
                  <p align=left>注：如果知道某事物应该成为一个基类，那么第一选择应该使它成为一个接口</p>
                </section>
                <section>
                  <h3>接口</h3>
                  <p align=left>2. 适配接口</p>
                  <p align=left>接口最吸引人的原因之一，就是允许同一个接口具有多个不同的具体实现；</p>
                  <p align=left>它的体现形式通常是一个接受接口类型的方法，而该接口的实现和向该方法传递的对象则取决于方法的使用者。</p>
                  <p align=left>典型运用就是策略模式</p>
                  <img src="tupian/tupian3.gif">
                  <pre><code data-trim contenteditable>
                    public Context(IStrategy strategy){
    this.strategy = strategy;
  }
  Scanner类的构造方法：参数也是使用接口
  public Scanner(Readable source){
    this(source,WHITESPACE_PATTERN)
  }
                </code></pre>
                </section>
                <section>
                  <h3>接口</h3>
                  <p align=left>3. 接口中的域</p>
                  <p align=left>接口中的域默认就是static final</p>
                  <p align=left>jdk1.5以前其可以实现与enum类似的作用</p>
                  <p align=left>接口可以嵌套在类或其他接口中</p>
                  <p align=left>例如java.util.Map<K,V>中就嵌套了Entry<K,V></p>
                  </section>
                  <section>
                  <h3>接口</h3>
                  <p align=left>4. 接口与工厂</p>
                  <p align=left>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂模式</p>
                  </section>
                </section>

                <section>
                <h3>目录</h3>
					<ul>
						<li>Java面向对象程序设计的基本特征</li>
						<li>接口</li>
						<li class="fragment highlight-blue"><strong>内部类</strong></li>
						<li>泛型</li>
						<li>字符串</li>
					</ul>
                </section>
                
                <section>
                   <section>
                      <h3>内部类</h3>
                      <p align=left>1. 内部类的定义</p>
                      <p align=left>可以将一个类的定义放在另一个类的定义内部，这就是内部类</p>
                      <p align=left>2. 当我们建立一个inner class时，其对象就拥有了与外部类对象之间的一种关系，这是通过一个特殊的this reference形式的，使得内部类对象可以随意的访问外部类中所有的成员。</p>
                      <pre><code data-trim contenteditable>
                        public class Outer{
         private int index = 100;
         private void print(){
                Inner i = new Inner();
                i.print();
         }
         class Inner{
               private void print(){
                  System.out.println(index);
               }
         }
         public static void main(String[] args){
                Outer o = new Outer();
                o.print();
         }        
}
                      </code></pre>
                   </section>
                   <section>
                     <h3>内部类</h3>
                      <p align=left>3. 使用.this与.new</p>
                      <p align=left>a. 在内部类中生成对外部类对象的引用.this</p>
                      <pre><code data-trim contenteditable>
                        public class DotThis {
     void f() {
       System.out.println(“DotThis.f()”);
     }
     public class Inner{
        public DotThis outer(){
        //在内部类方法中生成对外部类的引用
           return DotThis.this;
        }
     }
  }
                     </code></pre>
                     <p align=left>b. 在其他类中创建内部类对象.new要通过外部类的一个引用来创建</p>
                     <pre><code data-trim contenteditable>
                       public class DotNew{
    public class Inner {}
    public static void main(String[] args){
      //其它类要访问内部类时
      //要使用外部类的引用来创建内部类的引用
      DotNew dn = new DotNew();
      DotNew.Inner dni = dn.new Inner();
    }
}
                     </code></pre>
                   </section>
                   <section>
                     <h3>内部类</h3>
                      <p align=left>4. 在方法与作用域内的内部类</p>
                      <p align=left>可以在一个方法里面或者在任意的作用域内定义内部类，理由如下：</p>
                      <p align=left>a. 实现了某类型的接口，于是可以创建并返回对其的引用。</p>
                      <p align=left>b. 解决复杂问题，需要创建一个类来辅助解决，但是又不希望这个类是公共可用的。</p>
                   </section>
                   <section>
                     <h3>内部类</h3>
                      <p align=left>5. 匿名内部类</p>
                      <p align=left>匿名内部类更像是一个表达式，大概如new XXX(){},它可以理解为两个过程：</p>
                      <p align=left>a. 继承或实现(new XXX() XXX可以表示类也可以是接口)</p>
                      <p align=left>b. 实例化</p>
                   </section>
                   <section>
                     <h3>内部类</h3>
                      <p align=left>6. 内部类标识符</p>
                      <p align=left>外部类$内部类</p>
                      <img src="tupian/tupian4.gif">
                      <p align=left>如果是匿名内部类，则会产生一个数字来表示</p>
                      <img src="tupian/tupian5.gif">
                   </section>
                </section> 
                
               	<section>
					<h3>目录</h3>
					<ul>
						<li>Java面向对象程序设计的基本特征</li>
						<li>接口</li>
						<li>内部类</li>
						<li class="fragment highlight-blue"><strong>泛型</strong></li>
						<li>字符串</li>
					</ul>
				</section>
				
				<section>
				   <section>
                     <h3>泛型</h3>
                      <p align=left>1. 泛型概述</p>
                      <p align=left>泛型是在JDK1.4之后引入的，实现了参数化类型的概念，使代码可以应用于多种类型。理解了边界(能做什么，不能做什么)所在，你才能成为程序高手。因为只有知道了某个技术不能做到什么，你才能更好的做到所能做的，及弥补它的不足。</p>
                   </section>
                   <section>
                     <h3>泛型</h3>
                      <p align=left>2. 泛型及元组</p>
                      <p align=left>仅一次方法调用就能返回多个对象</p>
                      <pre><code data-trim contenteditable>
                        class Holder2 &#60;A,B&#62;{
    private A first;
    private B second;
    public Holder2(A a,B b) { first = a; second = b;}
    public String toStrinig() {
         return "(" + first + "," + second +")";
    }
  } 
                      </code></pre>
                   </section>
                   <section>
                    <h3>泛型</h3>
                      <p align=left>3. 泛型接口</p>
                      <pre><code data-trim contenteditable>
                      interface Generator &#60;T&#62; { 
    T next(); 
  } 
  public class Ted implements Generator &#60;String&#62;{
    public String next(){ 
      return ""; 
    }
  }
                      </code></pre>
                   </section>
                   <section>
                     <h3>泛型</h3>
                      <p align=left>4. 泛型方法</p>
                      <p align=left>必须将泛型参数列表置于返回值之前</p>
                      <pre><code data-trim contenteditable>
                      public class GenericMethods { 
    //将泛型参数列表置于返回值之前
    public &#60;T&#62; void f(T... args){ 
      return ; 
    } 
  }
                   </code></pre>
                   </section>
                   <section>
                     <h3>泛型</h3>
                      <p align=left>5. 擦除</p>
                      <p align=left>List&#60;String&#62;.class与List&#60;Integer&#62;.class是相同类型的，运行时对应的类型都是list。</p>
                      <p align=left>擦除丢失了在泛型代码中执行某些操作的能力。任何运行时需要知道确切类型信息的操作都将无法工作。</p>
                      <pre><code data-trim contenteditable>
                      List&#60;String&#62; a = new ArrayList&#60;String&#62;(); 
  List&#60;Integer&#62; b = new ArrayList&#60;Integer&#62;(); 
  System.out.println(a.getClass() == b.getClass()); 
  打印结果: true
                      </code></pre>
                   </section>
                   <section>
                      <h3>泛型</h3>
                      <p align=left>6. 总结</p>
                      <p align=left>a. 使用泛型的目的在于可表达性,而不仅仅是为了创建类型安全的容器在泛型出现之前,向容器中放的是object,取出来后要下转型</p>
                      <p align=left>b. 它是一种方法,通过它可以编写出更泛化的代码,这些代码对于它们能够作用的类型具有更少的限制,因此单个的代码段可以应用到更多的类型上</p>
                   </section>
                   </section>
                   
                   <section>
                    <h3>目录</h3>
					<ul>
						<li>Java面向对象程序设计的基本特征</li>
						<li>接口</li>
						<li>内部类</li>
						<li>泛型</li>
						<li class="fragment highlight-blue"><strong>字符串</strong></li>
					</ul>
                </section>
                
                <section>
                  <section>
                    <h3>字符串</h3>
                      <p align=left>1. String对象是不可变的</p>
                      <p align=left>String类中每一个看起来会修改String值的方法,实际上都是创建了一个全新的String对象,以包含修改后的字符串内容. 而最初的String对象丝毫未动。</p>
                      <p align=left>2. 重载+、+=和StringBuilder</p>
                      <p align=left>+与+=是java中仅有的两个重载过的操作符， +后面如果是非String类,会调用toString方法，Object的toString方法打印出来的是内存地址。StringBuilder非线程安全，StringBuffer线程安全。</p>
                  </section>
                  <section>
                  <h3>字符串</h3>
                      <p align=left>3. 正则表达式</p>
                      <pre><code data-trim contenteditable>
                      public static void main(String[] args) { 
  //将给定的正则表达式编译到模式中
  Pattern p = Pattern.compile("a*b"); 
  //创建匹配器
  Matcher m = p.matcher("aaaaab"); 
  //与模式进行匹配
  boolean b = m.matches();  
  System.out.println(b);  
  //合一写法(但这样写模式不能重用,适合一次匹配)
  b = Pattern.matches("a*b", "aaaaab"); 
  System.out.println(b); 
  //String中的matches
  String str = "1111"; 
  b= str.matches("\\d*"); 
  System.out.println(b);  
}  
                    </code></pre>
                  </section>
                </section>
                
				<section>
					<h3>谢谢!</h3>
					<img src="tupian/tupian6.gif">
				</section> 

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
				

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
